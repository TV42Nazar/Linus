# Завдання 1.15

Цей проєкт є реалізацією високоефективної утиліти для сортування складних структур даних мовою C.  
Програма демонструє навички системного програмування, роботи з пам'яттю та побудови паралельних обчислень.

Утиліта підтримує багатокритеріальне сортування та використовує бібліотеку OpenMP для розпаралелювання на багатоядерних системах.

---

## Основні можливості

### Багатокритеріальне сортування
1. За значенням `value` — **у порядку зростання**.
2. Якщо значення однакові — за `count` — **у порядку спадання**.

### Вибір алгоритму
- `qsort` — QuickSort
- `merge` — MergeSort
- `heap` — HeapSort

### Паралельна оптимізація
Використання OpenMP Tasks дозволяє динамічно розподіляти рекурсивні підзадачі між ядрами CPU.

---

## Технічні вимоги

- **ОС:** Ubuntu Server 20.04+
- **Компілятор:** GCC з підтримкою OpenMP
- **Пакети:** `build-essential`

---

## Встановлення залежностей
```bash
sudo apt update
sudo apt install build-essential -y
```
---

## Компіляція
Проєкт використовує бібліотеку OpenMP, тому необхідно додати прапорець -fopenmp
```bash
gcc -fopenmp sort_lab.c -o sort_app
```
---

##Інструкція з використання
**QuickSort**
```bash
./sort_app
```
**QuickSort**
```bash
./sort_app -t qsort
```
**Merge Sort**
```bash
./sort_app -t merge
```
**HeapSort**
```bash
./sort_app -t heap
```
---

## Архітектура та Принцип роботи

### Як це працює
**Структура `Item`**
Замість простих чисел використовуються об'єкти з двома полями (`value`, `count`) для імітації реальних даних.
**Параметри**
Залежно від параметрів буде вибрано відповідний спосіб сортування
**Кастомний компаратор**
Для структури було побудовано компаратор, що враховувує можливу дихотомію сортування, порівнюючи саме значення та к-сть повторень
**Merge sort**
Тут використовується механізм **OpenMP Tasks**. Рекурсивні виклики `mergeSort` загортаються в окремі задачі, які динамічно розподіляються між вільними ядрами CPU.
**Heap sort**
Тут використовується механізм **OpenMP Tasks**, хоч і в цьому варіанті сортування, на мою думку, воно не надто ефективне

Для кращого розуміння в код були додані коментарі, тому, якщо тут інформації замало, прошу звенутися до firstprac.c

---

### Послідовність виконання
1.  **Ініціалізація**
Програма зчитує аргумент `-t` та обирає стратегію (`qsort` або `merge`)
2.  **Розпаралелення**
    * Створюється пул потоків (`#pragma omp task`).
    * Головний потік запускає рекурсію.
3.  **Синхронізація**
`taskwait` гарантує, що злиття частин (`merge`) почнеться тільки коли обидва підпотоки завершать сортування
4.  **Результат**
Відсортований масив виводиться в `stdout`



